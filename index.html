<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radial Smooth Spline - Swanbourne Beach</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family:  'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:  linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .day-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .day-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .day-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .day-btn.active {
            background: white;
            color: #667eea;
            transform: scale(1.05);
        }
        
        .viz-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .viz-title {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }
        
        .viz-subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size:  1em;
        }
        
        .canvas-container {
            position: relative;
            width: 70%;
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top:  30px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1em;
        }
        
        .legend-color {
            width: 30px;
            height: 30px;
            border-radius:  6px;
        }
        
        .info-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top:  25px;
            text-align: center;
        }
        
        .info-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .info-text {
            color: #555;
            font-size: 0.95em;
            line-height:  1.6;
        }
        
        .location-label {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }
        
        .location-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .location-date {
            font-size: 1em;
            color: #666;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border:  2px solid #ef5350;
            border-radius:  12px;
            padding:  30px;
            margin-top: 25px;
            text-align: center;
        }
        
        .warning-title {
            font-weight: bold;
            color: #c62828;
            margin-bottom: 10px;
            font-size:  1.3em;
        }
        
        .warning-text {
            color: #d32f2f;
            font-size: 1em;
            line-height: 1.6;
        }
        
        .tab-menu {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
            transform: scale(1.05);
        }
        
        .chart-container {
            display: none;
        }
        
        .chart-container.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèñÔ∏è Swanbourne Beach Conditions</h1>
        
        <div class="day-selector" id="globalDaySelector">
        </div>
        
        <div class="tab-menu">
            <button class="tab-btn active" data-chart="separated">Separated Rings</button>
            <button class="tab-btn" data-chart="overlaid">Overlaid</button>
            <button class="tab-btn" data-chart="stacked">Stacked</button>
        </div>
        
        <div class="chart-container active" id="separatedChart">
        <div class="viz-card">
            <h2 class="viz-title">Swanbourne Beach</h2>
            <p class="viz-subtitle" id="chartDate">Loading...</p>
            
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
            </div>
            
            <div class="location-label">
                <div class="location-name">Swanbourne Beach</div>
                <div class="location-date" id="currentDate">Loading...</div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #F28C28;"></div>
                    <span><strong>Temperature</strong> (ideal: 32¬∞C)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1F5FA8;"></div>
                    <span><strong>Water Temp</strong> (warmer is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #32dbae;"></div>
                    <span><strong>Wind Speed</strong> (ideal: 0-15 km/h)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c1cad9;"></div>
                    <span><strong>Cloud Cover</strong> (less is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7993e8;"></div>
                    <span><strong>Precipitation</strong> (background)</span>
                </div>
            </div>
            
            <div class="info-box">
                <div class="info-title">How to Read This Chart</div>
                <div class="info-text">
                    The chart flows clockwise from 7am (left) through 12pm-1pm (top) to 7pm (right) in a semi-circle arc. 
                    Each colored ring represents a different metric in its own range. Temperature (innermost), Water Temp, Wind Speed, and Cloud Cover (outermost, inverted).
                    Precipitation probability is shown as a water droplet pattern in the background of each hour segment.
                    Higher values within each ring indicate better scores (closer to ideal conditions). 
                    Time labels and detailed readings appear around the outside of the chart.
                </div>
            </div>
        </div>
        </div>
        
        <div class="chart-container" id="overlaidChart">
        <div class="viz-card">
            <h2 class="viz-title">Overlaid Comparison</h2>
            <p class="viz-subtitle" id="chartDate2">Loading...</p>
            
            <div class="canvas-container">
                <canvas id="overlayCanvas"></canvas>
            </div>
            
            <div class="location-label">
                <div class="location-name">Swanbourne Beach</div>
                <div class="location-date" id="currentDate2">Loading...</div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #F28C28;"></div>
                    <span><strong>Temperature</strong> (ideal: 32¬∞C)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1F5FA8;"></div>
                    <span><strong>Water Temp</strong> (warmer is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #32dbae;"></div>
                    <span><strong>Wind Speed</strong> (ideal: 0-15 km/h)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c1cad9;"></div>
                    <span><strong>Cloud Cover</strong> (less is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7993e8;"></div>
                    <span><strong>Precipitation</strong> (background)</span>
                </div>
            </div>
            
            <div class="info-box">
                <div class="info-title">How to Read This Chart</div>
                <div class="info-text">
                    This chart shows all metrics overlaid in the same 0-1 range, making it easy to compare them directly. 
                    The chart flows clockwise from 7am (left) through 12pm-1pm (top) to 7pm (right) in a semi-circle arc. 
                    Precipitation probability is shown as a water droplet pattern in the background of each hour segment.
                    Higher values indicate better scores (closer to ideal conditions). 
                    Time labels and detailed readings appear around the outside of the chart.
                </div>
            </div>
        </div>
        </div>
        
        <div class="chart-container" id="stackedChart">
        <div class="viz-card">
            <h2 class="viz-title">Stacked View</h2>
            <p class="viz-subtitle" id="chartDate3">Loading...</p>
            
            <div class="canvas-container">
                <canvas id="stackedCanvas"></canvas>
            </div>
            
            <div class="location-label">
                <div class="location-name">Swanbourne Beach</div>
                <div class="location-date" id="currentDate3">Loading...</div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #F28C28;"></div>
                    <span><strong>Temperature</strong> (ideal: 32¬∞C)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1F5FA8;"></div>
                    <span><strong>Water Temp</strong> (warmer is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #32dbae;"></div>
                    <span><strong>Wind Speed</strong> (ideal: 0-15 km/h)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c1cad9;"></div>
                    <span><strong>Cloud Cover</strong> (less is better)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7993e8;"></div>
                    <span><strong>Precipitation</strong> (background)</span>
                </div>
            </div>
            
            <div class="info-box">
                <div class="info-title">How to Read This Chart</div>
                <div class="info-text">
                    This chart shows all metrics stacked on top of each other in the same 0-1 range. 
                    Temperature forms the base layer, Water Temp is stacked on top, Wind Speed comes next, and Cloud Cover (inverted) at the outermost.
                    Precipitation probability is shown as a water droplet pattern in the background of each hour segment.
                    The chart flows clockwise from 7am (left) through 12pm-1pm (top) to 7pm (right) in a semi-circle arc. 
                    The total height at any time shows the combined scores of all metrics.
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <script>
        var weatherData = [];
        var currentDay = 0;
        var isLoading = true;
        
        // Generate mock weather data for testing
        function generateMockData() {
            var mockData = [];
            var today = new Date();
            
            // Generate data for next 7 days
            for (var day = 0; day < 7; day++) {
                var date = new Date(today);
                date.setDate(today.getDate() + day);
                var dateKey = date.toISOString().split('T')[0];
                
                var dayData = {
                    date: dateKey,
                    hours: [],
                    temp: [],
                    wind: [],
                    water: [],
                    precipitation: [],
                    cloudCover: []
                };
                
                // Generate hourly data from 7am to 7pm
                for (var hour = 7; hour <= 19; hour++) {
                    dayData.hours.push(hour);
                    
                    // Temperature varies throughout the day (cooler in morning, warmer at noon)
                    var tempBase = 28 + day * 0.5; // Slight variation across days
                    var tempVariation = 6 * Math.sin((hour - 7) * Math.PI / 12); // Peaks at noon
                    dayData.temp.push(Math.round(tempBase + tempVariation));
                    
                    // Wind speed varies (typically lower in morning)
                    var windBase = 10 + day * 0.3;
                    var windVariation = 8 * Math.sin((hour - 7) * Math.PI / 10);
                    dayData.wind.push(Math.max(0, Math.round(windBase + windVariation)));
                    
                    // Water temperature is more stable
                    var waterBase = 24 + day * 0.2;
                    dayData.water.push(Math.round(waterBase * 10) / 10);
                    
                    // Precipitation probability (random for mock data)
                    var precipBase = 20 + day * 5;
                    var precipVariation = 30 * Math.sin((hour - 7) * Math.PI / 8);
                    dayData.precipitation.push(Math.max(0, Math.min(100, Math.round(precipBase + precipVariation))));
                    
                    // Cloud cover (random for mock data)
                    var cloudBase = 30 + day * 10;
                    var cloudVariation = 40 * Math.sin((hour - 7) * Math.PI / 9);
                    dayData.cloudCover.push(Math.max(0, Math.min(100, Math.round(cloudBase + cloudVariation))));
                }
                
                mockData.push(dayData);
            }
            
            return mockData;
        }
        
        // Fetch weather data from Open-Meteo API
        function fetchWeatherData() {
            var weatherApiUrl = 'https://api.open-meteo.com/v1/forecast?latitude=-31.9688&longitude=115.7673&hourly=temperature_2m,wind_speed_10m,precipitation_probability,cloud_cover&timezone=Australia/Perth';
            var marineApiUrl = 'https://marine-api.open-meteo.com/v1/marine?latitude=-31.9688&longitude=115.7673&hourly=sea_surface_temperature&timezone=Asia%2FSingapore';
            
            // Fetch both weather and marine data (marine is optional)
            Promise.allSettled([
                fetch(weatherApiUrl).then(function(response) {
                    if (!response.ok) throw new Error('Failed to fetch weather data');
                    return response.json();
                }),
                fetch(marineApiUrl).then(function(response) {
                    if (!response.ok) throw new Error('Failed to fetch marine data');
                    return response.json();
                })
            ])
                .then(function(results) {
                    var weatherResult = results[0];
                    var marineResult = results[1];
                    
                    if (weatherResult.status === 'rejected') {
                        console.error('Error fetching weather data:', weatherResult.reason);
                        console.log('Using mock data for testing');
                        weatherData = generateMockData();
                        isLoading = false;
                        updateChart();
                        updateDateDisplay();
                        updateDayButtons();
                        return;
                    }
                    
                    var weatherApiData = weatherResult.value;
                    var marineData = marineResult.status === 'fulfilled' ? marineResult.value : null;
                    
                    if (marineResult.status === 'rejected') {
                        console.warn('Marine data unavailable, using estimated values:', marineResult.reason);
                    }
                    
                    processWeatherData(weatherApiData, marineData);
                    isLoading = false;
                    updateChart();
                    updateDateDisplay();
                    updateDayButtons();
                })
                .catch(function(error) {
                    console.error('Unexpected error:', error);
                    console.log('Using mock data for testing');
                    weatherData = generateMockData();
                    isLoading = false;
                    updateChart();
                    updateDateDisplay();
                    updateDayButtons();
                });
        }
        
        function processWeatherData(data, marineData) {
            // Validate API response structure
            if (!data || !data.hourly || !data.hourly.time || !data.hourly.temperature_2m || !data.hourly.wind_speed_10m) {
                console.error('Invalid API response structure');
                showDataWarning('Invalid data format received from API');
                return;
            }
            
            var hourly = data.hourly;
            var times = hourly.time;
            var temperatures = hourly.temperature_2m;
            var windSpeeds = hourly.wind_speed_10m;
            var precipitationProb = hourly.precipitation_probability || [];
            var cloudCover = hourly.cloud_cover || [];
            
            // Process marine data if available, but don't fail if it's invalid
            var marineTimes = null;
            var seaTemperatures = null;
            
            if (marineData && marineData.hourly && marineData.hourly.time && marineData.hourly.sea_surface_temperature) {
                marineTimes = marineData.hourly.time;
                seaTemperatures = marineData.hourly.sea_surface_temperature;
            } else {
                console.warn('Marine data not available, will use estimated water temperatures');
            }
            
            // Validate that temperature and wind data are arrays with values
            if (!Array.isArray(temperatures) || !Array.isArray(windSpeeds) || 
                temperatures.length === 0 || windSpeeds.length === 0) {
                console.error('Temperature or wind data is missing or invalid');
                showDataWarning('Temperature or wind data is missing from API response');
                return;
            }
            
            // Check for invalid data (null, undefined, or non-numeric values)
            var hasInvalidTemp = temperatures.some(function(t) { return t == null || typeof t !== 'number' || isNaN(t); });
            var hasInvalidWind = windSpeeds.some(function(w) { return w == null || typeof w !== 'number' || isNaN(w); });
            
            if (hasInvalidTemp || hasInvalidWind) {
                console.error('Temperature or wind data contains invalid values');
                showDataWarning('Temperature or wind data contains invalid values');
                return;
            }
            
            // Create a map of marine data for easy lookup with fuzzy matching
            var marineDataMap = {};
            if (marineTimes && seaTemperatures) {
                // Validate seaTemperatures contains only valid numbers
                var hasInvalidSeaTemp = seaTemperatures.some(function(t) { return t == null || typeof t !== 'number' || isNaN(t); });
                
                if (hasInvalidSeaTemp) {
                    console.warn('Sea temperature data contains invalid values, will use estimated water temperatures');
                } else {
                    for (var i = 0; i < marineTimes.length; i++) {
                        var marineTime = new Date(marineTimes[i]).getTime();
                        marineDataMap[marineTimes[i]] = {
                            timestamp: marineTime,
                            temperature: seaTemperatures[i]
                        };
                    }
                }
            }
            
            // Group data by day
            var dayMap = {};
            
            for (var i = 0; i < times.length; i++) {
                var dateTime = new Date(times[i]);
                var dateKey = dateTime.toISOString().split('T')[0];
                var hour = dateTime.getHours();
                
                // Only include hours from 7am to 7pm
                if (hour >= 7 && hour <= 19) {
                    if (!dayMap[dateKey]) {
                        dayMap[dateKey] = {
                            date: dateKey,
                            hours: [],
                            temp: [],
                            wind: [],
                            water: [],
                            precipitation: [],
                            cloudCover: []
                        };
                    }
                    
                    dayMap[dateKey].hours.push(hour);
                    dayMap[dateKey].temp.push(Math.round(temperatures[i]));
                    dayMap[dateKey].wind.push(Math.round(windSpeeds[i]));
                    
                    // Add precipitation probability (0-100%)
                    var precip = precipitationProb[i];
                    dayMap[dateKey].precipitation.push(precip != null ? Math.round(precip) : 0);
                    
                    // Add cloud cover (0-100%)
                    var cloud = cloudCover[i];
                    dayMap[dateKey].cloudCover.push(cloud != null ? Math.round(cloud) : 0);
                    
                    // Get water temperature from marine API with fuzzy matching or estimate if not available
                    var waterTemp = null;
                    var ONE_HOUR_MS = 60 * 60 * 1000; // 1 hour in milliseconds
                    
                    if (Object.keys(marineDataMap).length > 0) {
                        var currentTime = new Date(times[i]).getTime();
                        var exactMatch = marineDataMap[times[i]];
                        
                        if (exactMatch) {
                            waterTemp = exactMatch.temperature;
                        } else {
                            // Find nearest time within 1 hour tolerance
                            var closestTime = null;
                            var minDiff = Infinity;
                            
                            for (var marineKey in marineDataMap) {
                                var timeDiff = Math.abs(marineDataMap[marineKey].timestamp - currentTime);
                                if (timeDiff < minDiff) {
                                    minDiff = timeDiff;
                                    closestTime = marineKey;
                                }
                            }
                            
                            // Only use the closest match if it's within 1 hour tolerance
                            if (closestTime && minDiff <= ONE_HOUR_MS) {
                                waterTemp = marineDataMap[closestTime].temperature;
                            }
                        }
                    }
                    
                    // Using != null to check for both null and undefined
                    if (waterTemp != null && typeof waterTemp === 'number' && !isNaN(waterTemp)) {
                        dayMap[dateKey].water.push(Math.round(waterTemp * 10) / 10);
                    } else {
                        // Fallback to estimate
                        dayMap[dateKey].water.push(Math.round((temperatures[i] - 2.5) * 10) / 10);
                    }
                }
            }
            
            // Convert to array and validate we have data
            weatherData = Object.values(dayMap);
            
            // Sort weatherData by date to ensure chronological order
            weatherData.sort(function(a, b) {
                return new Date(a.date) - new Date(b.date);
            });
            
            if (weatherData.length === 0) {
                console.error('No valid weather data found in the expected time range');
                showDataWarning('No weather data available for the selected time period');
                return;
            }
        }
        
        function showDataWarning(message) {
            var vizCard = document.querySelector('.viz-card');
            var warningBox = document.createElement('div');
            warningBox.className = 'warning-box';
            warningBox.innerHTML = '<div class="warning-title">‚ö†Ô∏è Data Error</div><div class="warning-text">' + message + '</div>';
            
            // Clear existing content
            var canvasContainer = document.querySelector('.canvas-container');
            var legend = document.querySelector('.legend');
            var infoBox = document.querySelector('.info-box');
            var locationLabel = document.querySelector('.location-label');
            
            if (canvasContainer) canvasContainer.style.display = 'none';
            if (legend) legend.style.display = 'none';
            if (infoBox) infoBox.style.display = 'none';
            if (locationLabel) locationLabel.style.display = 'none';
            
            // Insert warning after subtitle
            var subtitle = document.querySelector('.viz-subtitle');
            if (subtitle) {
                subtitle.parentNode.insertBefore(warningBox, subtitle.nextSibling);
            }
        }
        
        function updateDateDisplay() {
            if (weatherData.length > 0 && weatherData[currentDay]) {
                var dateStr = weatherData[currentDay].date;
                var dateObj = new Date(dateStr + 'T00:00:00');
                var options = { month: 'short', day: 'numeric', year: 'numeric' };
                var formattedDate = dateObj.toLocaleDateString('en-US', options);
                document.getElementById('currentDate').textContent = formattedDate;
                // Also update the chart subtitle with the date
                var chartDateElement = document.getElementById('chartDate');
                if (chartDateElement) {
                    chartDateElement.textContent = formattedDate;
                }
                // Update second chart date displays
                var currentDate2Element = document.getElementById('currentDate2');
                if (currentDate2Element) {
                    currentDate2Element.textContent = formattedDate;
                }
                var chartDate2Element = document.getElementById('chartDate2');
                if (chartDate2Element) {
                    chartDate2Element.textContent = formattedDate;
                }
                // Update third chart date displays
                var currentDate3Element = document.getElementById('currentDate3');
                if (currentDate3Element) {
                    currentDate3Element.textContent = formattedDate;
                }
                var chartDate3Element = document.getElementById('chartDate3');
                if (chartDate3Element) {
                    chartDate3Element.textContent = formattedDate;
                }
            }
        }
        
        function updateDayButtons() {
            var daySelector = document.getElementById('globalDaySelector');
            daySelector.innerHTML = '';
            
            // Get today's date at midnight for comparison
            var today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Track if we need to update currentDay to the first available future date
            var firstFutureDay = -1;
            var currentDayDateObj = weatherData[currentDay] ? new Date(weatherData[currentDay].date + 'T00:00:00') : null;
            var isCurrentDayPast = currentDayDateObj && currentDayDateObj < today;
            
            // Create a button for each day found in the data, but only for today and future dates
            for (var i = 0; i < weatherData.length; i++) {
                var dateObj = new Date(weatherData[i].date + 'T00:00:00');
                
                // Only create button if date is today or in the future
                if (dateObj >= today) {
                    // Track the first future day index
                    if (firstFutureDay === -1) {
                        firstFutureDay = i;
                    }
                    
                    // If current day is in the past, use the first future day for the active state
                    var dayToCheck = isCurrentDayPast ? firstFutureDay : currentDay;
                    
                    var btn = document.createElement('button');
                    btn.className = 'day-btn' + (i === dayToCheck ? ' active' : '');
                    btn.setAttribute('data-day', i);
                    
                    var monthDay = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    
                    // Display the actual date for each day in the data
                    btn.textContent = monthDay;
                    
                    daySelector.appendChild(btn);
                }
            }
            
            // If current day is in the past, automatically select the first future day
            if (isCurrentDayPast && firstFutureDay !== -1) {
                currentDay = firstFutureDay;
                updateChart();
                updateDateDisplay();
            }
        }
        
        // Calculate a normalized score from 0 to 1 based on how close value is to ideal
        // Uses cubic B√©zier spline falloff: score = 1 in ideal range, falls off smoothly outside
        function calculateRating(value, ideal, min, max, z1, z2) {
            // Default z1 and z2 values if not provided
            if (z1 === undefined) z1 = 0.5;
            if (z2 === undefined) z2 = 0.5;
            
            var idealMin, idealMax;
            
            if (Array.isArray(ideal)) {
                // Ideal is a range [min_ideal, max_ideal]
                idealMin = ideal[0];
                idealMax = ideal[1];
            } else {
                // Ideal is a single value, treat as a range with width 0
                idealMin = ideal;
                idealMax = ideal;
            }
            
            // If value is in the ideal range, return perfect score
            if (value >= idealMin && value <= idealMax) {
                return 1.0;
            }
            
            // Calculate parameter t based on whether value is below or above ideal range
            var t;
            if (value < idealMin) {
                // Below ideal range
                if (idealMin === min) {
                    // All values at or below ideal are perfect
                    return 1.0;
                }
                t = 1 - (idealMin - value) / (idealMin - min);
            } else {
                // Above ideal range
                if (idealMax === max) {
                    // All values at or above ideal are perfect
                    return 1.0;
                }
                t = 1 - (value - idealMax) / (max - idealMax);
            }
            
            // Clamp t to [0, 1] range
            t = Math.max(0, Math.min(1, t));
            
            // Calculate L constant
            var L = 0.6 * Math.sqrt(2);
            
            // Calculate B√©zier control points P1y and P2y
            var P1y = L * Math.sin((Math.PI / 4) * (1 - z1));
            var P2y = 1 - L * Math.sin((Math.PI / 4) * z2);
            
            // Calculate cubic B√©zier function B(t)
            // B(t) = 3(1-t)¬≤¬∑t¬∑P1y + 3(1-t)¬∑t¬≤¬∑P2y + t¬≥
            var oneMinusT = 1 - t;
            var B_t = 3 * oneMinusT * oneMinusT * t * P1y +
                      3 * oneMinusT * t * t * P2y +
                      t * t * t;
            
            // Clamp score to [0, 1] range
            var score = Math.max(0, Math.min(1, B_t));
            
            return score;
        }
        
        function calculateDayScores(dayData) {
            var scores = [];
            for (var i = 0; i < dayData.hours.length; i++) {
                var tempScore = calculateRating(dayData.temp[i], 32, 22, 40);
                var windScore = calculateRating(dayData.wind[i], [0, 15], 0, 30);
                var waterScore = calculateRating(dayData.water[i], 29, 19, 29);
                
                // Precipitation: lower is better (0% = 1.0 score, 100% = 0.0 score)
                var precipScore = 1 - (dayData.precipitation[i] / 100);
                
                // Cloud cover: stored as raw percentage for visualization
                // Also calculate score: lower is better (0% = 1.0 score, 100% = 0.0 score)
                var cloudCoverValue = dayData.cloudCover[i];
                var cloudScore = 1 - (cloudCoverValue / 100);
                
                var combined = (tempScore + windScore + waterScore + precipScore + cloudScore) / 5;
                
                scores.push({
                    hour: dayData.hours[i],
                    temp: dayData.temp[i],
                    wind: dayData.wind[i],
                    water: dayData.water[i],
                    precipitation: dayData.precipitation[i],
                    cloudCover: cloudCoverValue,
                    tempScore: tempScore,
                    windScore: windScore,
                    waterScore: waterScore,
                    precipScore: precipScore,
                    cloudCoverNormalized: cloudCoverValue / 100,
                    combined: combined
                });
            }
            // Sort scores by hour to ensure chronological order (7am to 7pm)
            scores.sort(function(a, b) { return a.hour - b.hour; });
            return scores;
        }
        
        function formatTime(hour) {
            if (hour === 12) return '12pm';
            if (hour < 12) return hour + 'am';
            return (hour - 12) + 'pm';
        }
        
        // Helper function to draw a water droplet
        function drawDroplet(ctx, x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            // Draw teardrop shape
            ctx.bezierCurveTo(
                x - size, y - size * 0.5,
                x - size, y - size * 1.5,
                x, y - size * 2
            );
            ctx.bezierCurveTo(
                x + size, y - size * 1.5,
                x + size, y - size * 0.5,
                x, y
            );
            ctx.fill();
        }
        
        // Catmull-Rom spline interpolation
        function getCatmullRomPoint(t, p0, p1, p2, p3) {
            var t2 = t * t;
            var t3 = t2 * t;
            
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 +
                   (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
                   v0 * t + p1;
        }
        
        function createSmoothPath(points, segments) {
            var smoothPoints = [];
            
            for (var i = 0; i < points.length - 1; i++) {
                var p0 = points[Math.max(0, i - 1)];
                var p1 = points[i];
                var p2 = points[i + 1];
                var p3 = points[Math.min(points.length - 1, i + 2)];
                
                for (var s = 0; s < segments; s++) {
                    var t = s / segments;
                    var angle = getCatmullRomPoint(t, p0.angle, p1.angle, p2.angle, p3.angle);
                    var radius = getCatmullRomPoint(t, p0.radius, p1.radius, p2.radius, p3.radius);
                    smoothPoints.push({ angle: angle, radius: radius });
                }
            }
            
            smoothPoints.push(points[points.length - 1]);
            return smoothPoints;
        }
        
        function drawRadialSpline(scores) {
            var canvas = document.getElementById('mainCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            
            // Make canvas responsive to container width
            var container = canvas.parentElement;
            if (!container) return;
            var containerWidth = container.clientWidth;
            var width = containerWidth || 1000; // Fallback to default width
            var height = width * 0.6; // Aspect ratio adjusted for larger display (60% height)
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Calculate spacing for labels around the chart
            // Labels are positioned at radius + 50, data values at radius + 90
            // Reserve space on all sides for these labels
            var sidePadding = 120; // Space needed on left/right for labels + data values
            var topPadding = 100; // Space needed at top for labels + data values
            var bottomPadding = 20; // Small space at bottom
            
            // Calculate center position and maximum radius
            var cx = width / 2;
            var cy = height - bottomPadding; // Position near bottom with small margin
            
            // Maximum radius is constrained by available space: 
            // 1. Vertical:  cy - topPadding (for top labels)
            // 2. Horizontal: cx - sidePadding (for left/right labels, center is at width/2)
            var maxRadiusVertical = cy - topPadding;
            var maxRadiusHorizontal = cx - sidePadding;
            var maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            // Calculate inner radius and layer heights
            // New order: Temperature, Water Temp, Wind, Cloud Cover (inverted)
            // Cloud cover has a margin, so we'll allocate space as: 3 layers + margin + cloud layer
            var innerRadius = maxAllowedRadius * 0.25; // Inner radius is 25% of max radius
            var availableSpace = maxAllowedRadius - innerRadius;
            var cloudMargin = availableSpace * 0.1; // 10% margin before cloud layer
            var cloudLayerHeight = availableSpace * 0.2; // 20% for cloud layer
            var dataLayers = 3; // Temperature, Water, Wind
            var maxHeight = (availableSpace - cloudMargin - cloudLayerHeight) / dataLayers;
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles (9 o'clock to 3 o'clock, going UP and over = PI to 2*PI, clockwise)
            var startAngle = Math.PI; // 9 o'clock (left side) - 7am
            var endAngle = 2 * Math.PI; // 3 o'clock (right side) - 7pm
            var angleRange = Math.PI; // semicircle going through the top
            
            // Create point arrays for each metric
            var tempPoints = [];
            var waterPoints = [];
            var windPoints = [];
            var cloudPoints = [];
            
            // Inner and outer boundaries for each ring section
            var tempInnerPoints = [];
            var waterInnerPoints = [];
            var windInnerPoints = [];
            var cloudOuterPoints = []; // Cloud layer outer boundary (inverted from here)
            
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange; // add to go clockwise (left to right via top)
                
                // Scores are 0-1, calculate layer thicknesses for each separate ring
                // Order from center out: Temperature, Water Temp, Wind, Cloud Cover
                
                var tempLayerHeight = s.tempScore * maxHeight;
                var waterLayerHeight = s.waterScore * maxHeight;
                var windLayerHeight = s.windScore * maxHeight;
                
                // Cloud cover is inverted: grows down from outer edge
                // The outer edge is at: innerRadius + 3*maxHeight + cloudMargin + cloudLayerHeight
                // Cloud data grows inward by cloudCoverNormalized * cloudLayerHeight
                var cloudOuterRadius = innerRadius + 3 * maxHeight + cloudMargin + cloudLayerHeight;
                var cloudInnerRadius = cloudOuterRadius - s.cloudCoverNormalized * cloudLayerHeight;
                
                // Temperature ring: offset 0
                tempInnerPoints.push({ angle: angle, radius: innerRadius });
                tempPoints.push({ angle: angle, radius: innerRadius + tempLayerHeight });
                
                // Water ring: offset 1*maxHeight
                waterInnerPoints.push({ angle: angle, radius: innerRadius + maxHeight });
                waterPoints.push({ angle: angle, radius: innerRadius + maxHeight + waterLayerHeight });
                
                // Wind ring: offset 2*maxHeight
                windInnerPoints.push({ angle: angle, radius: innerRadius + 2 * maxHeight });
                windPoints.push({ angle: angle, radius: innerRadius + 2 * maxHeight + windLayerHeight });
                
                // Cloud ring: inverted from outer edge
                cloudOuterPoints.push({ angle: angle, radius: cloudOuterRadius });
                cloudPoints.push({ angle: angle, radius: cloudInnerRadius });
            }
            
            // Create smooth curves for outer boundaries
            var smoothTemp = createSmoothPath(tempPoints, 10);
            var smoothWater = createSmoothPath(waterPoints, 10);
            var smoothWind = createSmoothPath(windPoints, 10);
            var smoothCloud = createSmoothPath(cloudPoints, 10);
            
            // Create smooth curves for inner boundaries
            var smoothTempInner = createSmoothPath(tempInnerPoints, 10);
            var smoothWaterInner = createSmoothPath(waterInnerPoints, 10);
            var smoothWindInner = createSmoothPath(windInnerPoints, 10);
            var smoothCloudOuter = createSmoothPath(cloudOuterPoints, 10);
            
            // Draw precipitation droplets in background (for each hour segment)
            for (var i = 0; i < scores.length - 1; i++) {
                var s = scores[i];
                var nextS = scores[i + 1];
                var precipIntensity = s.precipitation / 100; // 0 to 1
                
                if (precipIntensity > 0) {
                    var t1 = i / (scores.length - 1);
                    var t2 = (i + 1) / (scores.length - 1);
                    var angle1 = startAngle + t1 * angleRange;
                    var angle2 = startAngle + t2 * angleRange;
                    var midAngle = (angle1 + angle2) / 2;
                    
                    // Number of droplets based on precipitation probability (consistent across all charts)
                    var numDroplets = Math.floor(precipIntensity * 12) + 2;
                    
                    // Draw droplets in this segment, falling toward center
                    for (var d = 0; d < numDroplets; d++) {
                        // Random position within the segment
                        var angleOffset = (Math.random() - 0.5) * (angle2 - angle1) * 0.8;
                        var dropAngle = midAngle + angleOffset;
                        var radiusPos = innerRadius + Math.random() * (cloudOuterPoints[i].radius - innerRadius);
                        
                        var dropX = cx + Math.cos(dropAngle) * radiusPos;
                        var dropY = cy + Math.sin(dropAngle) * radiusPos;
                        
                        // Droplet size varies with intensity
                        var dropSize = 2 + precipIntensity * 3;
                        
                        // Calculate rotation to point toward center
                        var angleToCenter = Math.atan2(cy - dropY, cx - dropX);
                        
                        ctx.save();
                        ctx.translate(dropX, dropY);
                        ctx.rotate(angleToCenter);
                        
                        // Draw droplet with precipitation color
                        var alpha = 0.3 + precipIntensity * 0.3;
                        ctx.fillStyle = 'rgba(121, 147, 232, ' + alpha + ')'; // #7993e8
                        drawDroplet(ctx, 0, 0, dropSize);
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw temperature ring (innermost) - #F28C28
            ctx.fillStyle = 'rgba(242, 140, 40, 0.5)';
            ctx.beginPath();
            for (var i = 0; i < smoothTemp.length; i++) {
                var x = cx + Math.cos(smoothTemp[i].angle) * smoothTemp[i].radius;
                var y = cy + Math.sin(smoothTemp[i].angle) * smoothTemp[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothTempInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothTempInner[i].angle) * smoothTempInner[i].radius;
                var y = cy + Math.sin(smoothTempInner[i].angle) * smoothTempInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(200, 100, 20, 0.8)'; // Darker stroke
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw water temp ring (second layer) - #1F5FA8
            ctx.fillStyle = 'rgba(31, 95, 168, 0.5)';
            ctx.beginPath();
            for (var i = 0; i < smoothWater.length; i++) {
                var x = cx + Math.cos(smoothWater[i].angle) * smoothWater[i].radius;
                var y = cy + Math.sin(smoothWater[i].angle) * smoothWater[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothWaterInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothWaterInner[i].angle) * smoothWaterInner[i].radius;
                var y = cy + Math.sin(smoothWaterInner[i].angle) * smoothWaterInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(15, 50, 120, 0.8)'; // Darker stroke
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw wind ring (third layer) - #32dbae
            ctx.fillStyle = 'rgba(50, 219, 174, 0.5)';
            ctx.beginPath();
            for (var i = 0; i < smoothWind.length; i++) {
                var x = cx + Math.cos(smoothWind[i].angle) * smoothWind[i].radius;
                var y = cy + Math.sin(smoothWind[i].angle) * smoothWind[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothWindInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothWindInner[i].angle) * smoothWindInner[i].radius;
                var y = cy + Math.sin(smoothWindInner[i].angle) * smoothWindInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(20, 150, 120, 0.8)'; // Darker stroke
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw cloud cover ring (outermost, inverted) - #c1cad9
            ctx.fillStyle = 'rgba(193, 202, 217, 0.5)';
            ctx.beginPath();
            for (var i = 0; i < smoothCloudOuter.length; i++) {
                var x = cx + Math.cos(smoothCloudOuter[i].angle) * smoothCloudOuter[i].radius;
                var y = cy + Math.sin(smoothCloudOuter[i].angle) * smoothCloudOuter[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothCloud.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothCloud[i].angle) * smoothCloud[i].radius;
                var y = cy + Math.sin(smoothCloud[i].angle) * smoothCloud[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(140, 150, 170, 0.8)'; // Darker stroke
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw stroke lines and labels for each section boundary
            // Temperature section boundary (at innerRadius)
            ctx.strokeStyle = 'rgba(242, 140, 40, 1.0)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (var i = 0; i < smoothTempInner.length; i++) {
                var x = cx + Math.cos(smoothTempInner[i].angle) * smoothTempInner[i].radius;
                var y = cy + Math.sin(smoothTempInner[i].angle) * smoothTempInner[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Water temp section boundary (at innerRadius + maxHeight)
            ctx.strokeStyle = 'rgba(31, 95, 168, 1.0)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (var i = 0; i < smoothWaterInner.length; i++) {
                var x = cx + Math.cos(smoothWaterInner[i].angle) * smoothWaterInner[i].radius;
                var y = cy + Math.sin(smoothWaterInner[i].angle) * smoothWaterInner[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Wind section boundary (at innerRadius + 2*maxHeight)
            ctx.strokeStyle = 'rgba(50, 219, 174, 1.0)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (var i = 0; i < smoothWindInner.length; i++) {
                var x = cx + Math.cos(smoothWindInner[i].angle) * smoothWindInner[i].radius;
                var y = cy + Math.sin(smoothWindInner[i].angle) * smoothWindInner[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Cloud cover section boundary (outer edge)
            ctx.strokeStyle = 'rgba(193, 202, 217, 1.0)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (var i = 0; i < smoothCloudOuter.length; i++) {
                var x = cx + Math.cos(smoothCloudOuter[i].angle) * smoothCloudOuter[i].radius;
                var y = cy + Math.sin(smoothCloudOuter[i].angle) * smoothCloudOuter[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw text labels along the splines
            // Temperature label (at innerRadius, start of arc)
            ctx.save();
            var tempLabelAngle = startAngle + 0.1;
            var tempLabelRadius = innerRadius;
            var tempLabelX = cx + Math.cos(tempLabelAngle) * tempLabelRadius;
            var tempLabelY = cy + Math.sin(tempLabelAngle) * tempLabelRadius;
            ctx.translate(tempLabelX, tempLabelY);
            ctx.rotate(tempLabelAngle + Math.PI / 2);
            ctx.fillStyle = 'rgba(242, 140, 40, 1.0)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Temperature', 0, 0);
            ctx.restore();
            
            // Water label (at innerRadius + maxHeight)
            ctx.save();
            var waterLabelAngle = startAngle + 0.1;
            var waterLabelRadius = innerRadius + maxHeight;
            var waterLabelX = cx + Math.cos(waterLabelAngle) * waterLabelRadius;
            var waterLabelY = cy + Math.sin(waterLabelAngle) * waterLabelRadius;
            ctx.translate(waterLabelX, waterLabelY);
            ctx.rotate(waterLabelAngle + Math.PI / 2);
            ctx.fillStyle = 'rgba(31, 95, 168, 1.0)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Water Temp', 0, 0);
            ctx.restore();
            
            // Wind label (at innerRadius + 2*maxHeight)
            ctx.save();
            var windLabelAngle = startAngle + 0.1;
            var windLabelRadius = innerRadius + 2 * maxHeight;
            var windLabelX = cx + Math.cos(windLabelAngle) * windLabelRadius;
            var windLabelY = cy + Math.sin(windLabelAngle) * windLabelRadius;
            ctx.translate(windLabelX, windLabelY);
            ctx.rotate(windLabelAngle + Math.PI / 2);
            ctx.fillStyle = 'rgba(50, 219, 174, 1.0)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Wind Speed', 0, 0);
            ctx.restore();
            
            // Cloud label (at outer edge)
            ctx.save();
            var cloudLabelAngle = startAngle + 0.1;
            var cloudLabelRadius = cloudOuterPoints[0].radius;
            var cloudLabelX = cx + Math.cos(cloudLabelAngle) * cloudLabelRadius;
            var cloudLabelY = cy + Math.sin(cloudLabelAngle) * cloudLabelRadius;
            ctx.translate(cloudLabelX, cloudLabelY);
            ctx.rotate(cloudLabelAngle + Math.PI / 2);
            ctx.fillStyle = 'rgba(193, 202, 217, 1.0)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Cloud Cover', 0, 0);
            ctx.restore();
            
            // Draw time labels and markers
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange;
                
                // Find the outermost radius for this angle (cloud outer edge)
                var maxRadius = cloudOuterPoints[i].radius;
                
                // Draw radial line from inner to outer
                ctx.strokeStyle = 'rgba(200,200,200,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(angle) * innerRadius, cy + Math.sin(angle) * innerRadius);
                ctx.lineTo(cx + Math.cos(angle) * (maxRadius + 20), cy + Math.sin(angle) * (maxRadius + 20));
                ctx.stroke();
                
                // Time labels - positioned outside the chart
                var labelDist = maxRadius + 50;
                var x = cx + Math.cos(angle) * labelDist;
                var y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(formatTime(s.hour), x, y);
                
                // Draw data values in a ring around the chart
                var dataDist = maxRadius + 90;
                var dx = cx + Math.cos(angle) * dataDist;
                var dy = cy + Math.sin(angle) * dataDist;
                
                // Data label spacing constant
                var labelSpacing = 15;
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#F28C28';
                ctx.fillText(s.temp + '¬∞C', dx, dy - labelSpacing * 2);
                ctx.fillStyle = '#1F5FA8';
                ctx.fillText(s.water + '¬∞C', dx, dy - labelSpacing);
                ctx.fillStyle = '#32dbae';
                ctx.fillText(s.wind + ' km/h', dx, dy);
                ctx.fillStyle = '#c1cad9';
                ctx.fillText(s.cloudCover + '% ‚òÅ', dx, dy + labelSpacing);
                ctx.fillStyle = '#7993e8';
                ctx.fillText(s.precipitation + '% üíß', dx, dy + labelSpacing * 2);
            }
            
            // Center circle is now empty (no label)
        }
        
        function drawOverlaidChart(scores) {
            var canvas = document.getElementById('overlayCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            
            // Make canvas responsive to container width
            var container = canvas.parentElement;
            if (!container) return;
            var containerWidth = container.clientWidth;
            var width = containerWidth || 1000; // Fallback to default width
            var height = width * 0.6; // Aspect ratio adjusted for larger display (60% height)
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Calculate spacing for labels around the chart
            var sidePadding = 120; // Space needed on left/right for labels + data values
            var topPadding = 100; // Space needed at top for labels + data values
            var bottomPadding = 20; // Small space at bottom
            
            // Calculate center position and maximum radius
            var cx = width / 2;
            var cy = height - bottomPadding; // Position near bottom with small margin
            
            // Maximum radius is constrained by available space
            var maxRadiusVertical = cy - topPadding;
            var maxRadiusHorizontal = cx - sidePadding;
            var maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            // Calculate inner radius and layer height
            var innerRadius = maxAllowedRadius * 0.25; // Inner radius is 25% of max radius
            var maxHeight = maxAllowedRadius - innerRadius; // All data uses the same 0-1 range
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles (9 o'clock to 3 o'clock, going UP and over = PI to 2*PI, clockwise)
            var startAngle = Math.PI; // 9 o'clock (left side) - 7am
            var endAngle = 2 * Math.PI; // 3 o'clock (right side) - 7pm
            var angleRange = Math.PI; // semicircle going through the top
            
            // Create point arrays for each metric (all in 0-1 range now)
            var tempPoints = [];
            var waterPoints = [];
            var windPoints = [];
            var cloudPoints = [];
            
            // Inner boundary (same for all)
            var innerPoints = [];
            
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange; // add to go clockwise (left to right via top)
                
                // All scores are 0-1, all overlaid in the same range
                var tempLayerHeight = s.tempScore * maxHeight;
                var waterLayerHeight = s.waterScore * maxHeight;
                var windLayerHeight = s.windScore * maxHeight;
                var cloudLayerHeight = s.cloudCoverNormalized * maxHeight;
                
                // All metrics share the same inner boundary
                innerPoints.push({ angle: angle, radius: innerRadius });
                
                // Each metric has its own outer boundary based on its score
                tempPoints.push({ angle: angle, radius: innerRadius + tempLayerHeight });
                waterPoints.push({ angle: angle, radius: innerRadius + waterLayerHeight });
                windPoints.push({ angle: angle, radius: innerRadius + windLayerHeight });
                cloudPoints.push({ angle: angle, radius: innerRadius + cloudLayerHeight });
            }
            
            // Create smooth curves for all boundaries
            var smoothTemp = createSmoothPath(tempPoints, 10);
            var smoothWater = createSmoothPath(waterPoints, 10);
            var smoothWind = createSmoothPath(windPoints, 10);
            var smoothCloud = createSmoothPath(cloudPoints, 10);
            var smoothInner = createSmoothPath(innerPoints, 10);
            
            // Draw precipitation droplets in background (for each hour segment)
            for (var i = 0; i < scores.length - 1; i++) {
                var s = scores[i];
                var precipIntensity = s.precipitation / 100;
                
                if (precipIntensity > 0) {
                    var t1 = i / (scores.length - 1);
                    var t2 = (i + 1) / (scores.length - 1);
                    var angle1 = startAngle + t1 * angleRange;
                    var angle2 = startAngle + t2 * angleRange;
                    var midAngle = (angle1 + angle2) / 2;
                    
                    var numDroplets = Math.floor(precipIntensity * 12) + 2;
                    
                    for (var d = 0; d < numDroplets; d++) {
                        var angleOffset = (Math.random() - 0.5) * (angle2 - angle1) * 0.8;
                        var dropAngle = midAngle + angleOffset;
                        var radiusPos = innerRadius + Math.random() * (maxAllowedRadius - innerRadius);
                        
                        var dropX = cx + Math.cos(dropAngle) * radiusPos;
                        var dropY = cy + Math.sin(dropAngle) * radiusPos;
                        
                        var dropSize = 2 + precipIntensity * 3;
                        var angleToCenter = Math.atan2(cy - dropY, cx - dropX);
                        
                        ctx.save();
                        ctx.translate(dropX, dropY);
                        ctx.rotate(angleToCenter);
                        
                        var alpha = 0.3 + precipIntensity * 0.3;
                        ctx.fillStyle = 'rgba(121, 147, 232, ' + alpha + ')';
                        drawDroplet(ctx, 0, 0, dropSize);
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw cloud cover ring (bottom layer) - #c1cad9
            ctx.fillStyle = 'rgba(193, 202, 217, 0.3)';
            ctx.beginPath();
            for (var i = 0; i < smoothCloud.length; i++) {
                var x = cx + Math.cos(smoothCloud[i].angle) * smoothCloud[i].radius;
                var y = cy + Math.sin(smoothCloud[i].angle) * smoothCloud[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(140, 150, 170, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw water temp ring - #1F5FA8
            ctx.fillStyle = 'rgba(31, 95, 168, 0.3)';
            ctx.beginPath();
            for (var i = 0; i < smoothWater.length; i++) {
                var x = cx + Math.cos(smoothWater[i].angle) * smoothWater[i].radius;
                var y = cy + Math.sin(smoothWater[i].angle) * smoothWater[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(15, 50, 120, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw wind ring - #32dbae
            ctx.fillStyle = 'rgba(50, 219, 174, 0.3)';
            ctx.beginPath();
            for (var i = 0; i < smoothWind.length; i++) {
                var x = cx + Math.cos(smoothWind[i].angle) * smoothWind[i].radius;
                var y = cy + Math.sin(smoothWind[i].angle) * smoothWind[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(20, 150, 120, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw temperature ring (top layer) - #F28C28
            ctx.fillStyle = 'rgba(242, 140, 40, 0.3)';
            ctx.beginPath();
            for (var i = 0; i < smoothTemp.length; i++) {
                var x = cx + Math.cos(smoothTemp[i].angle) * smoothTemp[i].radius;
                var y = cy + Math.sin(smoothTemp[i].angle) * smoothTemp[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(200, 100, 20, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw the inner boundary circle
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (var i = 0; i < smoothInner.length; i++) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw time labels and markers
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange;
                
                // Find the outermost radius for this angle (maximum of all metrics)
                var maxRadius = Math.max(tempPoints[i].radius, windPoints[i].radius, waterPoints[i].radius, cloudPoints[i].radius);
                
                // Draw radial line from inner to outer
                ctx.strokeStyle = 'rgba(200,200,200,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(angle) * innerRadius, cy + Math.sin(angle) * innerRadius);
                ctx.lineTo(cx + Math.cos(angle) * (maxRadius + 20), cy + Math.sin(angle) * (maxRadius + 20));
                ctx.stroke();
                
                // Time labels - positioned outside the chart
                var labelDist = maxAllowedRadius + 50;
                var x = cx + Math.cos(angle) * labelDist;
                var y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(formatTime(s.hour), x, y);
                
                // Draw data values in a ring around the chart
                var dataDist = maxAllowedRadius + 90;
                var dx = cx + Math.cos(angle) * dataDist;
                var dy = cy + Math.sin(angle) * dataDist;
                
                // Data label spacing constant
                var labelSpacing = 15;
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#F28C28';
                ctx.fillText(s.temp + '¬∞C', dx, dy - labelSpacing * 2);
                ctx.fillStyle = '#1F5FA8';
                ctx.fillText(s.water + '¬∞C', dx, dy - labelSpacing);
                ctx.fillStyle = '#32dbae';
                ctx.fillText(s.wind + ' km/h', dx, dy);
                ctx.fillStyle = '#c1cad9';
                ctx.fillText(s.cloudCover + '% ‚òÅ', dx, dy + labelSpacing);
                ctx.fillStyle = '#7993e8';
                ctx.fillText(s.precipitation + '% üíß', dx, dy + labelSpacing * 2);
            }
        }
        
        function drawStackedChart(scores) {
            var canvas = document.getElementById('stackedCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            
            // Make canvas responsive to container width
            var container = canvas.parentElement;
            if (!container) return;
            var containerWidth = container.clientWidth;
            var width = containerWidth || 1000; // Fallback to default width
            var height = width * 0.6; // Aspect ratio adjusted for larger display (60% height)
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Calculate spacing for labels around the chart
            var sidePadding = 120; // Space needed on left/right for labels + data values
            var topPadding = 100; // Space needed at top for labels + data values
            var bottomPadding = 20; // Small space at bottom
            
            // Calculate center position and maximum radius
            var cx = width / 2;
            var cy = height - bottomPadding; // Position near bottom with small margin
            
            // Maximum radius is constrained by available space
            var maxRadiusVertical = cy - topPadding;
            var maxRadiusHorizontal = cx - sidePadding;
            var maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            // Calculate inner radius and layer height
            var innerRadius = maxAllowedRadius * 0.25; // Inner radius is 25% of max radius
            var maxHeight = maxAllowedRadius - innerRadius; // All data uses the full available range
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles (9 o'clock to 3 o'clock, going UP and over = PI to 2*PI, clockwise)
            var startAngle = Math.PI; // 9 o'clock (left side) - 7am
            var endAngle = 2 * Math.PI; // 3 o'clock (right side) - 7pm
            var angleRange = Math.PI; // semicircle going through the top
            
            // Create point arrays for stacked layers
            // Order: Temperature (base), Water, Wind, Cloud (top)
            var tempPoints = [];      // Base: temperature
            var waterPoints = [];     // Layer 2: temp + water
            var windPoints = [];      // Layer 3: temp + water + wind
            var cloudPoints = [];     // Layer 4: temp + water + wind + cloud
            
            // Inner boundary (same for all)
            var innerPoints = [];
            
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange; // add to go clockwise (left to right via top)
                
                // Stack the scores on top of each other
                var tempHeight = s.tempScore * maxHeight;
                var waterHeight = s.waterScore * maxHeight;
                var windHeight = s.windScore * maxHeight;
                var cloudHeight = s.cloudCoverNormalized * maxHeight;
                
                // Inner boundary
                innerPoints.push({ angle: angle, radius: innerRadius });
                
                // Layer 1: temperature only
                tempPoints.push({ angle: angle, radius: innerRadius + tempHeight });
                
                // Layer 2: temp + water
                waterPoints.push({ angle: angle, radius: innerRadius + tempHeight + waterHeight });
                
                // Layer 3: temp + water + wind
                windPoints.push({ angle: angle, radius: innerRadius + tempHeight + waterHeight + windHeight });
                
                // Layer 4: temp + water + wind + cloud
                cloudPoints.push({ angle: angle, radius: innerRadius + tempHeight + waterHeight + windHeight + cloudHeight });
            }
            
            // Create smooth curves for all boundaries
            var smoothTemp = createSmoothPath(tempPoints, 10);
            var smoothWater = createSmoothPath(waterPoints, 10);
            var smoothWind = createSmoothPath(windPoints, 10);
            var smoothCloud = createSmoothPath(cloudPoints, 10);
            var smoothInner = createSmoothPath(innerPoints, 10);
            
            // Draw precipitation droplets in background (for each hour segment)
            for (var i = 0; i < scores.length - 1; i++) {
                var s = scores[i];
                var precipIntensity = s.precipitation / 100;
                
                if (precipIntensity > 0) {
                    var t1 = i / (scores.length - 1);
                    var t2 = (i + 1) / (scores.length - 1);
                    var angle1 = startAngle + t1 * angleRange;
                    var angle2 = startAngle + t2 * angleRange;
                    var midAngle = (angle1 + angle2) / 2;
                    
                    var numDroplets = Math.floor(precipIntensity * 12) + 2;
                    
                    for (var d = 0; d < numDroplets; d++) {
                        var angleOffset = (Math.random() - 0.5) * (angle2 - angle1) * 0.8;
                        var dropAngle = midAngle + angleOffset;
                        var radiusPos = innerRadius + Math.random() * (maxAllowedRadius - innerRadius);
                        
                        var dropX = cx + Math.cos(dropAngle) * radiusPos;
                        var dropY = cy + Math.sin(dropAngle) * radiusPos;
                        
                        var dropSize = 2 + precipIntensity * 3;
                        var angleToCenter = Math.atan2(cy - dropY, cx - dropX);
                        
                        ctx.save();
                        ctx.translate(dropX, dropY);
                        ctx.rotate(angleToCenter);
                        
                        var alpha = 0.3 + precipIntensity * 0.3;
                        ctx.fillStyle = 'rgba(121, 147, 232, ' + alpha + ')';
                        drawDroplet(ctx, 0, 0, dropSize);
                        
                        ctx.restore();
                    }
                }
            }
            
            // Draw base layer (temperature) - #F28C28
            ctx.fillStyle = 'rgba(242, 140, 40, 0.6)';
            ctx.beginPath();
            for (var i = 0; i < smoothTemp.length; i++) {
                var x = cx + Math.cos(smoothTemp[i].angle) * smoothTemp[i].radius;
                var y = cy + Math.sin(smoothTemp[i].angle) * smoothTemp[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothInner.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(200, 100, 20, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw layer 2 (water temp) - #1F5FA8
            ctx.fillStyle = 'rgba(31, 95, 168, 0.6)';
            ctx.beginPath();
            for (var i = 0; i < smoothWater.length; i++) {
                var x = cx + Math.cos(smoothWater[i].angle) * smoothWater[i].radius;
                var y = cy + Math.sin(smoothWater[i].angle) * smoothWater[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothTemp.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothTemp[i].angle) * smoothTemp[i].radius;
                var y = cy + Math.sin(smoothTemp[i].angle) * smoothTemp[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(15, 50, 120, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw layer 3 (wind) - #32dbae
            ctx.fillStyle = 'rgba(50, 219, 174, 0.6)';
            ctx.beginPath();
            for (var i = 0; i < smoothWind.length; i++) {
                var x = cx + Math.cos(smoothWind[i].angle) * smoothWind[i].radius;
                var y = cy + Math.sin(smoothWind[i].angle) * smoothWind[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothWater.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothWater[i].angle) * smoothWater[i].radius;
                var y = cy + Math.sin(smoothWater[i].angle) * smoothWater[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(20, 150, 120, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw top layer (cloud cover) - #c1cad9
            ctx.fillStyle = 'rgba(193, 202, 217, 0.6)';
            ctx.beginPath();
            for (var i = 0; i < smoothCloud.length; i++) {
                var x = cx + Math.cos(smoothCloud[i].angle) * smoothCloud[i].radius;
                var y = cy + Math.sin(smoothCloud[i].angle) * smoothCloud[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (var i = smoothWind.length - 1; i >= 0; i--) {
                var x = cx + Math.cos(smoothWind[i].angle) * smoothWind[i].radius;
                var y = cy + Math.sin(smoothWind[i].angle) * smoothWind[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(140, 150, 170, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw the inner boundary circle
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (var i = 0; i < smoothInner.length; i++) {
                var x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                var y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw time labels and markers
            for (var i = 0; i < scores.length; i++) {
                var s = scores[i];
                var t = i / (scores.length - 1);
                var angle = startAngle + t * angleRange;
                
                // Find the outermost radius for this angle (top of stack)
                var maxRadius = cloudPoints[i].radius;
                
                // Draw radial line from inner to outer
                ctx.strokeStyle = 'rgba(200,200,200,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(angle) * innerRadius, cy + Math.sin(angle) * innerRadius);
                ctx.lineTo(cx + Math.cos(angle) * (maxRadius + 20), cy + Math.sin(angle) * (maxRadius + 20));
                ctx.stroke();
                
                // Time labels - positioned outside the chart
                var labelDist = maxAllowedRadius + 50;
                var x = cx + Math.cos(angle) * labelDist;
                var y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(formatTime(s.hour), x, y);
                
                // Draw data values in a ring around the chart
                var dataDist = maxAllowedRadius + 90;
                var dx = cx + Math.cos(angle) * dataDist;
                var dy = cy + Math.sin(angle) * dataDist;
                
                // Data label spacing constant
                var labelSpacing = 15;
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#F28C28';
                ctx.fillText(s.temp + '¬∞C', dx, dy - labelSpacing * 2);
                ctx.fillStyle = '#1F5FA8';
                ctx.fillText(s.water + '¬∞C', dx, dy - labelSpacing);
                ctx.fillStyle = '#32dbae';
                ctx.fillText(s.wind + ' km/h', dx, dy);
                ctx.fillStyle = '#c1cad9';
                ctx.fillText(s.cloudCover + '% ‚òÅ', dx, dy + labelSpacing);
                ctx.fillStyle = '#7993e8';
                ctx.fillText(s.precipitation + '% üíß', dx, dy + labelSpacing * 2);
            }
        }
        
        function updateChart() {
            if (weatherData.length > 0 && weatherData[currentDay]) {
                var scores = calculateDayScores(weatherData[currentDay]);
                drawRadialSpline(scores);
                drawOverlaidChart(scores);
                drawStackedChart(scores);
                updateDateDisplay();
            }
        }
        
        document.getElementById('globalDaySelector').addEventListener('click', function(e) {
            // Use closest() to handle clicks on button or any child elements
            var button = e.target.closest('.day-btn');
            if (button) {
                var buttons = document.querySelectorAll('.day-btn');
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].classList.remove('active');
                }
                button.classList.add('active');
                currentDay = parseInt(button.getAttribute('data-day'));
                updateChart();
            }
        });
        
        // Tab menu event listener
        document.querySelector('.tab-menu').addEventListener('click', function(e) {
            var button = e.target.closest('.tab-btn');
            if (button) {
                // Update tab buttons
                var tabButtons = document.querySelectorAll('.tab-btn');
                for (var i = 0; i < tabButtons.length; i++) {
                    tabButtons[i].classList.remove('active');
                }
                button.classList.add('active');
                
                // Update chart visibility
                var chartType = button.getAttribute('data-chart');
                var chartContainers = document.querySelectorAll('.chart-container');
                for (var i = 0; i < chartContainers.length; i++) {
                    chartContainers[i].classList.remove('active');
                }
                
                // Show the selected chart
                if (chartType === 'separated') {
                    document.getElementById('separatedChart').classList.add('active');
                } else if (chartType === 'overlaid') {
                    document.getElementById('overlaidChart').classList.add('active');
                } else if (chartType === 'stacked') {
                    document.getElementById('stackedChart').classList.add('active');
                }
            }
        });
        
        // Initialize by fetching weather data
        fetchWeatherData();
        
        var resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(updateChart, 250);
        });
    </script>
</body>
</html>
